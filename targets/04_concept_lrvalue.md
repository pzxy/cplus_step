[指针和引用](#指针和引用) 
[左值右值](#左值右值) 
[左值引用和右值引用](#左值引用和右值引用)

# 指针和引用
指针可能空,引用不会为空.
要点: `&`和`*`在等号左右边不同位置有不同含义
```cpp
int n;
// 这里的*表示指针pt是一个地址
int *pt = new int;
const int b = 101;
// 这里获取n的引用,要注意. 
// 这里的&表示引用,可以将int& 是一个整体,通用表示的话是 T&
int & rn = n;
// 这里的*是一个解引用操作符,会访问地址指向空间的值.
// 上面提到了 pt表示一个地址,所以这里的*pt就是获取pt指向的值
int & rt = *pt;
// 这里也可以将 const int & 看成一个整体.通用表示的话是 const T&
// 因为b是const int类型,要获取b的引用,规定只能是const T& 类型. 
const int & rb = b;
```
# 左值右值
左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式),但是不能对其应用地址运算符的值.

不必去管什么 `lvalue` ` rvalue` `glvalue` `xvalue` `prvalue` 

```cpp
int a = 3;// a是左值,3是右值
```

# 左值引用和右值引用

左值引用`T&`就是我们正常理解的引用
```cpp
int n;
int &rn = n;
```
注意: 一个常量只能绑定到常左值`const T&`引用
```cpp
const int b = 101;
const int &rb = b;
```

右值引用 `&&` ,含义就是可关联到右值.
```cpp
int x = 10;
int y = 23;
// && 表示右值引用
int && r1 = 13;
// 这里获取的是x+y表达式当前计算后的,值.后面改变x或y的值,不会影响到r2
int && r2 = x+y;
double && r3 = std::sqrt(2.0);
cout << r1 << endl;
// 将右值关联到右值引用导致该右值被存储到特定的位置，且可以获取该位置的地址。
// 也就是说，虽然不能将运算符&用于13，但可将其用于r1。
// 通过将数据与特定的地址关联，使得可以通过右值引用来访问该数据。
cout << *&r1 << endl;
```

# 移动语义和右值引用


对大多数程序员来说，右值引用带来的主要好处并非是让他们能够编写使用右值引用的代码，而是能够使用利用右值引用实现移动语义的库代码。例如，STL类现在都有复制构造函数、移动构造函数、复制赋值运算符和移动赋值运算符。
